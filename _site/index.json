{
  "MAP.html": {
    "href": "MAP.html",
    "title": "\uD83D\uDDFA️ Map Generation System — Roleworld Engine | docs",
    "summary": "\uD83D\uDDFA️ Map Generation System — Roleworld Engine This document explains how the map generation works in the Roleworld Engine. It provides a clear, technical overview of the process, suitable for developers and contributors who want to understand or modify the system. \uD83D\uDD27 Generation Steps 1. Generate Falloff Map Purpose: Makes the edges of the world more likely to be ocean. Push low elevation values near the borders Helps generate island-like or continent-like shapes 2. Generate Heightmap with Perlin Noise Purpose: Creates natural-looking terrain elevation. A 2D Perlin Noise is used Noise is normalized between 0 and 1 Falloff map is subtracted to ensure borders are lower 3. Determine Terrain Type from Elevation Purpose: Assign terrain based on height. Elevation Range Terrain Type < 0.3 Water < 0.4 Sand < 0.6 Grass < 0.8 Rock >= 0.8 Snow 4. Generate Voronoi Regions Purpose: Define coherent biome zones. Voronoi partitioning divides the world into regions Each region can be assigned a different biome category 5. Combine Layers Purpose: Merge noise + zones into a consistent visual map. Perlin controls local variation Voronoi (if used) enforces biome boundaries Final data is rendered to the screen using colored tiles \uD83C\uDFA8 Color Assignment Each terrain type is assigned a color for rendering: Terrain Color Water Blue Sand Yellow Grass Green Rock Gray Snow White \uD83D\uDCCC Notes All data is generated procedurally at runtime This system allows infinite variation while remaining deterministic (same seed → same map) Biome diversity can be increased later by layering temperature, region type, or civilization data This document will evolve as Roleworld's world generation system expands."
  },
  "PRD.html": {
    "href": "PRD.html",
    "title": "\uD83E\uDDE9 Product Requirements Document — RoleWorld Engine | docs",
    "summary": "\uD83E\uDDE9 Product Requirements Document — RoleWorld Engine \uD83D\uDCD8 Project Summary RoleWorld Engine is a handcrafted 2D engine built in C# using Silk.NET. It is designed to create living, systemic role-playing games (RPGs) where kingdoms, characters, and events interact in a persistent, GUI-only world. Inspired by simulations like Mount & Blade, Crusader Kings, and Dwarf Fortress, the engine serves as a sandbox for emergent storytelling and strategic freedom. \uD83C\uDFAF Goal To build a modular, libre engine enabling developers to craft: Living simulated worlds Player freedom with no predefined class or script Graphical-only interaction (no 3D rendering) Persistent systems with deep entity interconnections \uD83E\uDDE0 Design Principles \uD83C\uDFB2 Systemic Simulation: Every entity acts, evolves, and reacts independently. \uD83E\uDDED Interactive Strategic Map: The world is navigated through a zoomable 2D map. \uD83C\uDFAD Role Freedom: No mandatory objectives or win states — pure sandbox. \uD83D\uDCAC Complete GUI: All interaction is through windows, dialogs, panels, HUD. \uD83D\uDD01 Persistence & Replayability: All states are saved and reloadable. \uD83D\uDCDA Emergent Narrative: Stories emerge from systems, not scripts. \uD83D\uDEE0️ Tech Stack Language: C# (.NET 8+) Library: Silk.NET (OpenGL, GLFW, Input) Rendering: Custom 2D GUI (not Unity, not Godot) Architecture: Fully custom, built from the ground up \uD83D\uDC64 Target Audience Solo developers (like Sofiane) who want to create deep simulations Player-programmers who love building systems and watching them evolve Not aimed at the general public — no drag-and-drop, no prefab content ❌ Not Intended For ❌ 3D games ❌ Game creators looking for premade scenes or assets ❌ Action/arcade/platformer genres ❌ Visual editors or WYSIWYG tools \uD83D\uDD2E Inspirations Mount & Blade: Map-based freedom, evolving world Crusader Kings: Dynastic simulation, social depth Dungeons & Dragons: Open-ended roleplay \uD83D\uDCDC Conclusion RoleWorld Engine is a long-term, personal creation sandbox for systemic, strategic, GUI-driven RPGs. It doesn't impose any predefined rules — it offers tools to simulate, visualize, and interact with a fully living world."
  },
  "README.html": {
    "href": "README.html",
    "title": "| docs",
    "summary": "RoleWorld Engine is a 2D game engine written in C# using Silk.NET. It is designed for building systemic, persistent, and GUI-based role-playing simulations — where the world evolves independently of the player. This project focuses on modular simulation, emergent behavior, and custom UI logic without any 3D rendering or visual editors. Features System-driven world simulation Custom 2D GUI Entity-based design: characters, factions, traits Strategic map navigation Event-driven logic and AI decision-making Full persistence (save/load) Technologies Language: C# (.NET 8+) Low-level API: Silk.NET (OpenGL, GLFW, Input) Rendering: Immediate-mode 2D graphics Architecture: Fully handcrafted engine (no third-party engine layer) Getting Started git clone https://github.com/Sofiane5900/Roleworld-Engine cd RoleWorld-Engine dotnet run"
  },
  "Roleworld/ROADMAP.html": {
    "href": "Roleworld/ROADMAP.html",
    "title": "\uD83D\uDEE0️ RoleWorld Engine – Development Roadmap | docs",
    "summary": "\uD83D\uDEE0️ RoleWorld Engine – Development Roadmap This roadmap provides a step-by-step technical plan to implement the RoleWorld Engine from core logic to usable GUI tools. The goal is to start small, test internal logic early, and grow toward a modular and living system. ✅ Phase 1 — Core Loop & Simulation Skeleton Focus: Engine heartbeat, entity system, and simulation clock. [x] Create application window (Silk.NET.Windowing) [ ] Implement the main loop (HandleInput, UpdateSimulation, Render) [ ] Add time management: Tick, DeltaTime, and pause/resume [ ] Build a minimal Entity structure with unique ID [ ] Implement component storage (dictionary-based) [ ] Create a World class to manage all entities and systems \uD83E\uDDF1 Phase 2 — Entities & Components Design Focus: Make the world data-driven and modular. [ ] Define core components: [ ] Position [ ] Name [ ] Faction [ ] Age [ ] Add basic entity factory methods (create character, faction, town) [ ] Implement serialization-friendly data structures \uD83C\uDF00 Phase 3 — Systems & World Simulation Focus: Run logic across the world each tick. [ ] Create tick-based systems: [ ] AgeSystem (increment age) [ ] MovementSystem (random movement) [ ] EventSystem (chance-based events) [ ] Build a SimulationEngine class to manage all systems [ ] Log simulation steps to console for debugging (no GUI yet) \uD83D\uDCBE Phase 4 — Persistence Layer Focus: Save/load the entire world state. [ ] Implement a JSON-based save system [ ] Store all entities and components with metadata [ ] Add versioning to saves for future compatibility [ ] Load saved state into the World cleanly \uD83D\uDDFA️ Phase 5 — World Map (Visual Placeholder) Focus: Visual context of the world, non-interactive. [ ] Initialize OpenGL 2D context with Silk.NET [ ] Draw a static tiled map or background [ ] Render Position components as dots/entities [ ] Camera: Pan and Zoom support \uD83D\uDDB1️ Phase 6 — Input & Entity Selection Focus: Interact with the map. [ ] Capture mouse input & map coordinates [ ] Click to select an entity on the map [ ] Display data in console (or temporary overlay panel) [ ] Keyboard shortcuts for debug (pause, tick step) \uD83E\uDE9F Phase 7 — GUI Layer Focus: Build the windowing system and basic panels. [ ] Design minimal immediate-mode UI framework [ ] Create resizable, draggable windows [ ] Create entity inspection panel (name, stats, etc.) [ ] Implement context menus / actions \uD83D\uDD03 Phase 8 — Dynamic Events & AI Decisions Focus: Add systems that simulate autonomy and consequence. [ ] Add a basic event system (births, deaths, alliances) [ ] Create a DecisionSystem for autonomous character actions [ ] Log events and decisions chronologically [ ] Prepare GUI event history/log panel \uD83D\uDCDA Phase 9 — Documentation & Developer Tooling Focus: Prepare for open contribution and scaling. [ ] Generate code documentation [ ] Create usage examples (code + screenshots) [ ] Write contributing guide [ ] Add test scenes or simulation presets \uD83D\uDD2E Long-Term Ideas (Post-MVP) [ ] Procedural map generation [ ] Dynastic bloodline simulation [ ] Faction reputation and diplomatic memory [ ] Crime, culture, religion systems [ ] Modding support (JSON or scripting) \uD83E\uDDED Final Note Build systems first. GUI later. Everything observable via logs before UI. This roadmap is iterative — each phase builds upon the last. Small victories (like a character aging or a faction forming) are already wins. Stay modular. Stay systemic. Let the world live without you."
  },
  "TEST-PROCEDURAL.html": {
    "href": "TEST-PROCEDURAL.html",
    "title": "Test Plan - Procedural Map Generation | docs",
    "summary": "Test Plan - Procedural Map Generation Version: 1.0.0 Last Updated: June 30, 2025 Status: Draft \uD83D\uDCCB Table of Contents Purpose and Objectives Scope Testing Strategy Resources Test Environment Acceptance Criteria Test Deliverables Risks and Contingencies Timeline Reporting 1. Purpose and Objectives 1.1 Overview This document defines the test strategy and quality expectations for the Procedural Map Generation module of the RoleWorld Engine, focusing on the correctness, stability, and integration of noise, falloff, and biome logic. 1.2 Key Objectives Objective Description Priority Noise Validity Generated values must be deterministic and normalized High Falloff Quality Maps should visually match expected radial decay High Biome Accuracy Correct mapping of noise values to terrain types High Generation Speed Map generation must remain responsive (<1s for 128x128) Medium 2. Scope 2.1 Features to be Tested Core Procedural Systems [x] PerlinNoise float generation with smooth gradients [x] FalloffMap generation [x] Combination: FinalMap = Noise * Falloff [x] MapGenerator.Generate(...) data consistency [x] Biome classification based on height thresholds 2.2 Features Not in Scope ❌ UI rendering ❌ Saving/Loading system ❌ In-game simulation logic ❌ Event or faction systems 3. Testing Strategy 3.1 Test Types Matrix Test Type Focus Tools Priority Unit Perlin math, fade, dot product xUnit, FluentAssertions High Integration MapGenerator output structure xUnit + Mock Falloff High Visual Manual preview of map images Console / Debug Image Medium Performance Gen time & memory for 128x128+ Stopwatch / Profiler Medium 3.2 Testing Workflow stateDiagram-v2 [*] --> UnitTesting UnitTesting --> IntegrationTesting IntegrationTesting --> VisualDebug VisualDebug --> [*] 4.2 Stack & Tools Category Tools Development Rider 2025.1, .NET 8, C# Testing xUnit Debug / Logs Console 5 Dependencies None (no UI, no database) Headless environment (console-based only) 6. Acceptance Criteria 6.1 Core Tests Component Criteria PerlinNoise Normalized in [0,1], deterministic per input FalloffMap Central values > edge values, symmetrical decay MapData HeightMap and BiomeMap initialized, dimensions match input GetTerrainType Correct biome mapped per noise threshold Visual Debug Map shows smooth transitions, clear biome zones (manua"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | docs",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | docs",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | docs",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}